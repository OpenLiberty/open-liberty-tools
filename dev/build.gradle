/***********************************************************************
 * Copyright (c) 2017, 2020 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
************************************************************************/

buildscript {
    repositories {
        mavenCentral()
    }
}

plugins {
  id "org.hidetake.ssh" version "2.10.1"
}

// Declare ant deps and classpath separately
repositories {
    mavenCentral()
}

configurations {
    antcp
}

dependencies {
    antcp 'org.apache.ivy:ivy:2.4.0'
    antcp 'ant-contrib:ant-contrib:1.0b3'
    antcp 'org.osgi:org.osgi.core:4.3.0'
    antcp 'asm:asm-all:3.3.1'
    antcp 'org.apache.aries:org.apache.aries.util:1.1.3'
}

remotes {
    dhe {
        host = System.getenv("dhe_server")
        user = System.getenv("intranet.user")
        password = System.getenv("intranet.password")
        knownHosts = allowAnyHosts
    }
}

ssh.settings {
    jschLog = true
    logging = "stdout"
    fileTransfer = "scp"
    retryCount = 3
    retryWaitSec = 5
}

defaultTasks 'clean', 'compile', 'generateOpenLTUpdateSite', 'deployDHE'

task importAnt {
    ClassLoader antClassLoader = org.apache.tools.ant.Project.class.classLoader
    configurations.antcp.each { 
            File f ->
        antClassLoader.addURL(f.toURI().toURL())
    }

    // The below taskdefs are only used in prereqs.xml. build-olt.xml has its taskdefs loaded in the ant code.
    ant.taskdef(resource:'net/sf/antcontrib/antlib.xml',classpath:configurations.antcp.asPath)
    ant.taskdef(uri:'antlib:org.apache.ivy.ant', resource:'org/apache/ivy/ant/antlib.xml',classpath: configurations.antcp.asPath)

    // prereqs uses ivy to resolve and download our runtime dependencies and some open source libs
    // and move them into /lib/ folders of dependant plugins
    ant.importBuild('ant_build/prereqs/prereqs.xml')
    // build-olt provides the generateOpenLTUpdateSite target, which is the entry point
    // for the compilation and assembling of updatesites
    ant.importBuild('ant_build/build-olt.xml')
}

def projDir = projectDir.getAbsolutePath()
def antBuildFolderPath = projDir + project.properties['ant.build.folder']
def targetPlatformFolder = file(projDir + project.properties['target.platform.folder'])

// file to download the eclipse target platform archive into
def eclipseTargetPlatformArchive = file(projDir + project.properties['eclipse.target.platform.archive.location'])
// folder to extract the eclipse target platform archive into
def eclipseTargetPlatformIESFolder  = file(projDir + project.properties['eclipse.target.platform.ies.folder'])
def eclipseTargetPlatformFolder  = file(projDir + project.properties['eclipse.target.platform.folder'])

def eclipseTempFolder  = file(projDir + project.properties['eclipse.temp.folder'])
def toolsImageFolder  = file(projDir + project.properties['tools.image.folder'])
def toolsImagePluginsFolder  = file(projDir + project.properties['tools.image.plugins.folder'])
def artifactsFolder = file(projDir + '/' + project.properties['ant.artifacts.folder'])
def ivyCacheFolder  = file(System.getProperty("user.home") + '/.ivy2/cache')

// Download an Eclipse TargetPlatform
task downloadEclipseTargetPlatform {
    doLast {
        def eclipseTargetPlatformURL = new URL(project.properties['eclipse.target.platform.url'])

        if(!eclipseTargetPlatformIESFolder.exists() || eclipseTargetPlatformIESFolder.listFiles().length == 0) {
            eclipseTargetPlatformIESFolder.mkdirs()       
            
            if (!eclipseTempFolder.exists()) 
                eclipseTempFolder.mkdirs()

            if (!eclipseTargetPlatformArchive.exists()) {
                println 'Downloading Eclipse Target Platform into ' + eclipseTargetPlatformArchive.getAbsolutePath()
                
                eclipseTargetPlatformURL.withInputStream{ i -> eclipseTargetPlatformArchive.withOutputStream{ it << i }}
                
                println 'Finished downloading Eclipse Target Platform' 
                println 'Untar into ' + eclipseTargetPlatformIESFolder
            }
            else {
                println 'Untar existing ' + eclipseTargetPlatformArchive.getAbsolutePath() + ' into ' + eclipseTargetPlatformIESFolder
                println 'Run \'gradle clean build\' to build by downloading target platform files again.'
            }
            
            copy {
                from tarTree(eclipseTargetPlatformArchive)
                into eclipseTargetPlatformIESFolder
            }
        }
        else {
            println eclipseTargetPlatformIESFolder.getAbsolutePath() + ' already exists.'
        }
    }
    
    onlyIf {
        System.env['skip_compile_olt'] == null
    }
}

// file to download the sdk archive into
def eclipseSdkArchive = file(projDir + project.properties['eclipse.sdk.archive.location'])
// folder to extract the sdk archive into
def eclipseSdkFolder  = file(projDir + project.properties['eclipse.sdk.folder'])

// Download an Eclipse sdk archive. This provides APIs used to assemble the updatesites.
task downloadEclipseSDK {
    doLast {
        def eclipseSdkArchiveURL = new URL(project.properties['eclipse.sdk.url'])

        if(!eclipseSdkFolder.exists() || eclipseSdkFolder.listFiles().length == 0) {
            eclipseSdkFolder.mkdir()
            
             if (!eclipseSdkArchive.exists()) {
                 println 'Downloading Eclipse SDK into ' + eclipseSdkArchive.getAbsolutePath()
                 
                 eclipseSdkArchiveURL.withInputStream{ i -> eclipseSdkArchive.withOutputStream{ it << i }}
                 
                 println 'Finished downloading Eclipse SDK'
                 
                 println 'Untar into ' + eclipseSdkFolder
             }
             else {
                  println 'Untar existing ' + eclipseSdkArchive.getAbsolutePath() + ' into ' + eclipseSdkFolder
                  println 'Run \'gradle clean build\' to build by downloading Eclipse SDK files again'
             }

            copy {
                from tarTree(eclipseSdkArchive)
                into eclipseSdkFolder
            }
        }
        else {
            println eclipseSdkFolder.getAbsolutePath() + ' already exists.'
        }
    }
    
    onlyIf {
        System.env['skip_compile_olt'] == null
    }
}

task build {
    doLast {
    }
}

task gradleCompile {
    doLast {
    }
}

task gradleGenerateOpenLTUpdateSite {
    doLast {
    }
}

gradleGenerateOpenLTUpdateSite.dependsOn generateOpenLTUpdateSite

build.dependsOn compile
build.dependsOn generateOpenLTUpdateSite

preparePrereqsIvy.dependsOn importAnt
compile.dependsOn preparePrereqsIvy
compile.dependsOn downloadEclipseSDK
compile.dependsOn downloadEclipseTargetPlatform

gradleCompile.dependsOn compile

//// build version from the artifacts to avoid version mismatch
import static groovy.io.FileType.FILES

def getBuildLabelFromArtifact() {
    def filePrefix = System.getenv("FILE_PREFIX")
    def buildLabel = ""

    def files = ant.path {
            fileset(dir: 'ant_build/artifacts/', includes: "${filePrefix}*.zip")
    }

    files.list().each { file ->

        File aFile = new File(file)
        String fileName = aFile.getName()

        buildLabel = (fileName =~ "${filePrefix}(.*).zip")[0][1]

    if (buildLabel.isEmpty()) {
        buildLabel = ant.properties['buildLabel']
        println "Unable to grab build label - ant buildLabel is used instead."
        }
    }
    return buildLabel
}

import groovy.json.*

//// This method generates '${infoJson}' file in each build
def createJSONForBuild(version) {
        def infoJson = System.getenv("INFO_JSON")
        def filePrefix = System.getenv("FILE_PREFIX")
        def buildLog = System.getenv("BUILD_LOG")
    
        println "Creating ${infoJson} for ${version}."

        // Create JSON descriptor
        File infoJsonFile = new File("${rootDir}/${version}/${infoJson}")
        infoJsonFile.createNewFile()

        infoJsonFile.text = JsonOutput.prettyPrint(JsonOutput.toJson([
                                            build_log: "${buildLog}",
                                            driver_location: "${filePrefix}${version}.zip"
                                            ]))
}

// deploy build to DHE
task deployDHE {

    doLast {

        def user = System.getenv("intranet.user")
        def host = System.getenv("dhe_server")
        def pw = System.getenv("intranet.password")

        if(user == null || user.isEmpty()) {
            throw new GradleException("dhe user id is not set!")
        }
        if(pw == null || pw.isEmpty()) {
            throw new GradleException("dhe password is not set!")
        }
        if(host == null || host.isEmpty()) {
            throw new GradleException("dhe_server is not set!")
        }

        def version = getBuildLabelFromArtifact()
        def buildType = System.getenv("olt_build_type")
        def buildLog = System.getenv("BUILD_LOG")
        
        println "Publishing ${buildType} build: ${version}"
        
        def infoJson = System.getenv("INFO_JSON")
        
        def toPublishDir = "${rootDir}/${version}"
        mkdir(toPublishDir)

        // Put all files to be published into a directory
        def toPublish = ant.path {
             fileset(dir: 'ant_build/artifacts/', includes: "openlibertytools-*.zip")
        }
        
        toPublish.list().each { file ->
            println "Publishing " + file + " to DHE"
            copy {
                from file
                into toPublishDir
            }
        }
        
        if (buildType == "release") {
            createJSONForBuild("${version}")

            def toPublish_buildlog = ant.path {
                fileset(dir: '.', includes: "${buildLog}")
            }
            
            println "Publishing " + toPublish_buildlog + " to DHE"
            copy {
                from toPublish_buildlog
                into toPublishDir
            }
        }

        def userAtHost = user + "@" + host
        def dir = "/www/stage/export/pub/software/openliberty/tools"
        def destDHEStaging = userAtHost + ':' + dir

        println "Publishing build: ${version}"

        ssh.run {
            session(remotes.dhe) {
                put from: "${rootDir}/${version}", into: "${dir}/${buildType}/"
            }
        }

        println "Completed upload of artifacts"

        file(toPublishDir).deleteDir()

        if (buildType != "nightly") {

            //// Update '${buildType}/${infoJson}' with the newly published build
            ant.touch(file: "${rootDir}/${infoJson}")

            // Download ${infoJson} from destDHEStaging and use it if it's not emptied.
            println "Downloading ${destDHEStaging}/${buildType}/${infoJson}..."

            ssh.run {
                session(remotes.dhe) {
                    put from: "${dir}/${buildType}/${infoJson}", into: "${rootDir}/"
                }
            }

            File json = new File("${rootDir}/${infoJson}")

            def object = [:]

            // if ${infoJson} from the staging server is not empty
            if (json.getText() != null && json.getText() != "") {
                object = new JsonSlurper().parseText(json.getText())
            } else {
                  def infoJsonDHEPublicUrl = "http://public.dhe.ibm.com/ibmdl/export/pub/software/openliberty/tools/${buildType}/${infoJson}"

                  // if ${infoJson} in staging server is empty then download ${infoJson} from DHEPublic
                  println "${destDHEStaging}/${buildType}/${infoJson} is already published."
                  println "Downloading ${infoJsonDHEPublicUrl}"
    
                  URL infoJsonURL = new URL("${infoJsonDHEPublicUrl}")
                  def connection = infoJsonURL.openConnection()
    
                  // if ${infoJson} is not downloadable
                   if ("${connection.responseCode}" == "404") {
                      println "Response Code/Message: ${connection.responseCode} / ${connection.responseMessage}"
                  } else {
                      json << infoJsonURL.openStream()
                    object = new JsonSlurper().parseText(json.getText())
                  }
            }

            List versionsList = object['versions']
            if (versionsList != null) {
                versionsList.add("${version}")
            } else {
                versionsList = ["${version}"]
            }

            object['versions'] = versionsList
            json.text = JsonOutput.prettyPrint(JsonOutput.toJson(object))

            println "Publishing build list ${infoJson}"

            ssh.run {
                session(remotes.dhe) {
                    put from: "${rootDir}/${infoJson}", into: "${dir}/${buildType}/${infoJson}"
                }
            }
                    
            file("${rootDir}/${infoJson}").delete()
        }          
    }
    
    onlyIf {
        ((System.getenv("olt_build_type") == "nightly") || 
             (System.getenv("olt_build_type") == "release"))
    }
}

// Delete all prereq files and extracted SDK and target platform files.
task cleanPrereqs(type: Delete) {
    doLast {
        println 'Delete ' + eclipseSdkFolder
        file(eclipseSdkFolder).deleteDir()
        println 'Delete ' + eclipseTargetPlatformFolder
        file(eclipseTargetPlatformFolder).deleteDir()
        println 'Delete ' + ivyCacheFolder
        file(ivyCacheFolder).deleteDir()
        
        def prereqslibFolder  = file(projDir + project.properties['ant.prereqslib.folder'])
        println 'Delete ' + prereqslibFolder
        file(prereqslibFolder).deleteDir()
        
        // for each plugin, delete lib/ folder so that ivy will re-retrieve prereqs
        fileTree(dir: projDir, include: 'com.ibm.*/lib/').visit {  FileVisitDetails details ->
            if(details.file.isDirectory() && 'lib'.equals(details.file.name)) {
                println 'Delete ' + details.file.getPath()
                details.file.delete()
            }
        }
    }
    
    onlyIf {
        System.env['skip_compile_olt'] == null
    }
}

// clean build output folder
task cleanBuilds(type: Delete) {
    doLast {
        def artifactsDir = project.properties['ant.artifacts.folder']
        println 'Delete ' + artifactsDir
        file(artifactsDir).deleteDir()
        
        println 'Delete ' + toolsImageFolder
        file(toolsImageFolder).deleteDir()
    }
    
    onlyIf {
        System.env['skip_compile_olt'] == null
    }
}

// Delete all prereq files, downloaded artifacts and build output
task clean(type: Delete) {
    doLast {
        println 'Delete ' + eclipseSdkArchive
        file(eclipseSdkArchive).delete()
        println 'Delete ' + eclipseTargetPlatformArchive
        file(eclipseTargetPlatformArchive).delete()        
    }
    
    onlyIf {
        System.env['skip_compile_olt'] == null
    }
}

clean.dependsOn cleanBuilds, cleanPrereqs
